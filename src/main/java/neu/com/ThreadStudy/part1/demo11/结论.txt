停止线程3中方式：
1使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2使用stop方法强行终止线程，但是不推荐。stop和suspend及resume过期作废的方法。
3使用interrupt方法中断线程。
	
thread.interrupt(),仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。
判断线程是否停止：
	this.interrupted():测试当前线程是否已经中断。
		执行后具有将状态标志清除为false的功能。如果连续两次调用，第二次返回false。
	this.isInterrupted():测试线程是否已经中断
		不清除状态标志。
		
使用异常停止线程
在沉睡中停止：如果在sleep状态下停止某一线程，会进入catch语句，并且清除停止状态值，使之变成false
暴力停止：stop(),调用stop会抛出java.lang.ThreadDeath异常，但在通常情况下，此异常不需要显式捕获。
	废弃stop是因为强制 让线程停止则有可能使一些请理性的工作得不到完成，另外一个情况就是对锁定的对象进行了解锁，导致
	数据得不到同步的处理，出现数据不一致的问题。


使用return停止线程
public void run(){
	while(true){
		if(this.isInterrupted()){
			return;
		}
	}
}
不过还是建议使用抛异常的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止的事件得以传播。

使用suspend方法暂停线程，使用resume方法恢复线程
缺点：容易造成公共的同步对象的独占，使其他线程无法访问公共同步对象。
	还有一种锁占用
	容易出现因为线程的暂停而导致数据不同步的情况
	
yield方法：放弃当前的cpu资源，将它让给其他的任务去占用cpu执行时间。但放弃的时间不确定。

线程的优先级：setPriority();
线程优先级分1-10，如果>10 or <1抛异常 
jdk中预置了3个优先级的值
线程的优先级具有继承性，比如a线程启用b线程，则线程b的优先级与a是一样的。
	当优先级差别较大时，谁先执行完和代码的调用顺序无关。
	优先级具有随机性，也就是优先级高的线程不一定先执行完

守护线程：
	java中有两种线程，一种是用户线程， 一种是守护线程。典型的守护线程就是垃圾回收线程。
	
